/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package infrastructure.api;

import framework.web.error.BadRequest;
import framework.web.error.ClientError;
import framework.web.error.Unauthorized;
import infrastructure.MailServerSkeleton;
import infrastructure.TestingUser;
import org.checkerframework.checker.units.qual.A;
import org.junit.jupiter.api.*;
import framework.db.DbManager;
import server.infrastructure.DbManagerImpl;
import server.infrastructure.root.api.EventAPI;
import server.infrastructure.root.api.PaymentAPI;
import server.infrastructure.root.api.TicketsAPI;

import java.net.UnknownHostException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class PaymentAPITest {
    private static DbManager db;
    private final static MailServerSkeleton mail = new MailServerSkeleton();

    static ArrayList<Long> events;
    private static PaymentAPI.Ticket paymentTicket;
    private static List<TicketsAPI.Ticket> ticketTickets = new ArrayList<>();

    // This user will make payments
    private final static TestingUser u1 = new TestingUser("Yui", "yui@gmail.com", "saas");
    // This organizer will make things the user can pay for
    private final static TestingUser o1 = new TestingUser("Organizer", "organizer@gmail.com", "password");

    private static PaymentAPI.PaymentInfo paymentInfo;

    // Order
    private List<PaymentAPI.OrderItem> orderItemList = new ArrayList<>();
    private static PaymentAPI.Order order;

    @BeforeAll
    public static void setup() throws ClientError, SQLException, UnknownHostException {
        try{
            db = new DbManagerImpl("payment_api_test", true, true, true);
        }catch (Exception e){
            throw new RuntimeException(e);
        }

        // Make some fake users
        u1.register(mail, db, false);
        u1.login(mail, db, false);
        o1.register(mail, db, false);
        o1.login(mail, db, false);
        o1.makeOrganizer(db, null, mail);

        // Add payment info
        paymentInfo = new PaymentAPI.PaymentInfo("John Doe", "123 Doe Street", "0987654312345678", "09/12", "999");

        // Make fake event(s)
        var auth = o1.organizerSession(db, null);
        events = new ArrayList<>();
        try(var trans = db.rw_transaction(null)){
            events.add(EventAPI.create_event(auth, trans));
            trans.tryCommit();
        }
        try(var trans = db.rw_transaction(null)){
            EventAPI.set_draft(auth, trans, events.getLast(), false); // Event can't be a draft if we want to attach a ticket to it
            trans.tryCommit();
        }
        var update = new EventAPI.UpdateEvent();
        try(var trans = db.rw_transaction(null)){
            update.name = Optional.of("Hello, World!");
            update.description = Optional.of("hello world of events");
            update.type = Optional.of("Concert");
            update.category = Optional.of("Music");
            EventAPI.update_event(auth, trans, events.getLast(), update);
            trans.tryCommit();
        }

        // Create fake tickets for the fake event

        var session = o1.organizerSession(db, null);
        long ticket_id;
        try (var trans = db.rw_transaction(null)) {
            Long event_id = events.getFirst();
            ticket_id = TicketsAPI.create_ticket(session, trans, event_id);
            trans.tryCommit();
        }
        try (var trans = db.rw_transaction(null)) {
            var newTicket = new TicketsAPI.Ticket(ticket_id, "General Admission", 9_990000, 30L);
            ticketTickets.add(newTicket);
            TicketsAPI.update_ticket(session, ticketTickets.getLast(), ticket_id, trans);
            trans.tryCommit();
        }
        long ticket_id2;
        try (var trans = db.rw_transaction(null)) {
            Long event_id = events.getFirst();
            ticket_id2 = TicketsAPI.create_ticket(session, trans, event_id);
            trans.tryCommit();
        }
        try (var trans = db.rw_transaction(null)) {
            var newTicket = new TicketsAPI.Ticket(ticket_id2, "VIP", 39_990000, 10L);
            ticketTickets.add(newTicket);
            TicketsAPI.update_ticket(session, ticketTickets.getLast(), ticket_id2, trans);
            trans.tryCommit();
        }
    }

    @Test
    @Order(1)
    public void testCreatingEstimates() throws SQLException, Unauthorized {
        var userSesh = u1.userSession(db, null);

        // Make order
        orderItemList.add(new PaymentAPI.Ticket(ticketTickets.get(0).id()));
        orderItemList.add(new PaymentAPI.Ticket(ticketTickets.get(1).id()));
        orderItemList.add(new PaymentAPI.AccountOrganizerUpgrade());

        // Create that estimate
        PaymentAPI.Estimate est;
        try (var trans = db.ro_transaction(null)) {
            PaymentAPI.OrderItem[] orderListArr = new PaymentAPI.OrderItem[orderItemList.size()];
            for (int i = 0; i < orderItemList.size(); i++) {
                orderListArr[i] = orderItemList.get(i);
            }
            est = PaymentAPI.create_estimate(userSesh, trans, orderListArr);
//            System.out.println("\033[4;1mEstimate:\033[0m");
//            System.out.println("Items:");
//            for (PaymentAPI.ReceiptItem ri : est.items())
//                System.out.println("\t" + ri);

            Assertions.assertNotEquals(0, est.subtotal());
//            System.out.println("Subtotal:\t" + PaymentAPI.formatPrice(est.subtotal()));
//            System.out.println("Fees:\t\t" + PaymentAPI.formatPrice(est.fees()));
//            System.out.println("GST:\t\t" + PaymentAPI.formatPrice(est.gst()));
//            System.out.println("\033[1mTotal:\033[0m\t\t" + PaymentAPI.formatPrice(est.total()));
            Assertions.assertNotEquals(0, est.total());
        }
    }

    @Test
    @Order(2)
    public void testMakingPurchase() throws SQLException, ClientError {
        var userSesh = u1.userSession(db, null);

        //TODO check how many tickets there are before the purchase so we can see if it decreases after

        // Make an actual order
        order = new PaymentAPI.Order(orderItemList, paymentInfo);

        // Make purchase
        PaymentAPI.Receipt receipt;
        try (var trans = db.rw_transaction(null)) {
            receipt = PaymentAPI.make_purchase(userSesh, trans, order, null, mail);
            Assertions.assertNotNull(receipt);
//            System.out.println("Receipt 1 after purchase: " + receipt);
        }
        // Make a second purchase with just an account upgrade in it
        PaymentAPI.Order order2 = new PaymentAPI.Order(List.of(new PaymentAPI.AccountOrganizerUpgrade()), paymentInfo);
        try (var trans = db.rw_transaction(null)) {
            receipt = PaymentAPI.make_purchase(userSesh, trans, order2, null, mail);
            Assertions.assertNotNull(receipt);
//            System.out.println("Receipt 2 after purchase: " + receipt);
        }

        //TODO Check that there are less tickets left now after purchasing (need to wait until there is a way to detect this)
        TicketsAPI.Ticket ticket1, ticket2;
        Long event_id;
        try (var trans = db.ro_transaction(null)) {
            event_id = events.getFirst();
            Assertions.assertNotNull(event_id);
            List<TicketsAPI.Ticket> list = TicketsAPI.get_tickets(userSesh, trans, event_id);
            ticket1 = list.get(0);
            ticket2 = list.get(1);
        }
//        System.out.println("Tickets left for ticket \"" + ticket1.name() + "\" in event " + event_id + ": " + ticket1.total_tickets());
        Assertions.assertEquals(ticket1.total_tickets(), 30);
//        System.out.println("Tickets left for ticket \"" + ticket2.name() + "\" in event " + event_id + ": " + ticket2.total_tickets());
        Assertions.assertEquals(ticket2.total_tickets(), 10);
    }

    @Test
    @Order(3)
    public void testListingReceipts() throws SQLException, Unauthorized {
        var userSesh = u1.userSession(db, null);
        List<PaymentAPI.Receipt> rList;
        try (var trans = db.ro_transaction(null)) {
            rList = PaymentAPI.list_receipts(userSesh, trans);
        }
        Assertions.assertNotNull(rList);
        Assertions.assertEquals(2, rList.size()); // Make sure both orders show up
//        System.out.println("\033[4;1mReceipt List:\033[0m");
//        for (var i : rList)
//            System.out.println("\t" + i);
    }

    @AfterAll
    public static void close() {
        db.close();
    }
}
